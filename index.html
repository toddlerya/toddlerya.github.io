<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="witness me.">
<meta property="og:type" content="website">
<meta property="og:title" content="不期速成日拱一卒">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="不期速成日拱一卒">
<meta property="og:description" content="witness me.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="toddlerya">
<meta property="article:tag" content="不期速成日拱一卒">
<meta property="article:tag" content="独立">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="程序员">
<meta property="article:tag" content="个人">
<meta property="article:tag" content="思考">
<meta property="article:tag" content="读书">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="分享">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>不期速成日拱一卒</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="不期速成日拱一卒" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">不期速成日拱一卒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">但行好事，莫问前程</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/%E6%8A%8A%E4%BD%A0%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%BD%93%E4%BD%9C%E4%B8%80%E5%B9%85%E7%94%BB(%E9%82%B0%E6%99%93%E6%A2%85)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/%E6%8A%8A%E4%BD%A0%E7%9A%84%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%BD%93%E4%BD%9C%E4%B8%80%E5%B9%85%E7%94%BB(%E9%82%B0%E6%99%93%E6%A2%85)/" class="post-title-link" itemprop="url">把你的测试用例当作一幅画(邰晓梅)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 07:20:38" itemprop="dateCreated datePublished" datetime="2019-10-08T07:20:38+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本篇文章来自《海盗派测试分析MFQ&amp;PPDCS》作者邰晓梅，因原作者博客已经不再维护，现将文章转载记录于此。</p>
</blockquote>
<p>​        Kevin Fjelsted是一个盲人，他曾写了一篇文章《A Brief History of the Accessibility of Computers by Blind People》，收录在《Amplifying Your Effectiveness》一书中。文中从一个盲人的视角描述了几十年来计算机的演进和变化。</p>
<p>​          我对Kevin所描述的一个小细节很感兴趣：由于看不见，Kevin经常听别人为他描述一些图画或者画面。他发现，绝大部分人描述一幅画的时候，实际上是在描述一些画的特征，比如“画里有三个人”、“这是一副关于房子的画”。人们很少会描述画的细节部分，这就为听者留下了广泛的思考和遐想空间。</p>
<p>​          当你用文字表述一件事情或一个事务的时候，不论你用多少文字、多么精雕细琢，当让接收者亲自去体验这件事情的时候，比如亲自用眼睛看这幅画、或者亲自动手去实验一下，接收者总是会有新的感受、会发现一些文字之外的东西。这就是一副图画可能胜过万语千言的道理了。</p>
<p>​        对照我们的测试，写作测试用例的时候，不就是试图用文字向测试执行人员传达测试设计人员的想法吗？从传递者的角度，也许你期望不同的执行人员拿到这个用例，其执行结果都是一样的，希望测试效果受测试执行人员经验的影响降到最低，因此你试图准确而详细地描述每一个步骤。然而你的测试用例是不可能写得事无巨细的，因为不会有那么多的时间允许你这么做（假如你真的有这么多的时间，我倒建议你多做做探索性测试、多想想更有价值的测试内容）；另外一方面，即使真的给你这么多时间写详尽的测试用例，你仍然无法保证囊括每一个与之相关的细节。从接收者的角度，优秀的测试执行人员阅读测试用例，就要像欣赏一幅画一 样，<strong>不仅仅靠听</strong>－－这样只能接到别人描述的表面特征，<strong>更重要的是靠看</strong>－－用你的眼睛去观察，去想一想设计人员是怎么想的？设计这个用例的目的是什么？为什么要这样设计用例？我怎样测试才能保证最优的测试效果？和用例相关的部分哪些也值得我关注？哪些是我所知道的重要信息但用例却没有提到？我应该以怎样的顺序执行这些用例为佳？我以大概怎样的进度执行这些用例比较合适？<strong>最重要的是靠动手</strong>－－用你的心去思考，当你拿到一份待执行的用例，如果上述问题，你通过审视用例，就基本了然于胸，那很好。如果不是这样，比如你对被测特性还不大了解，也没有关系，你可以在执行用例的过程中进一步思考这些问题，通过动手操作，你得到了被测对象的一些最真实的反馈，你对测试用例有了更深刻的认识，你也在随时调整着自己的测试策略。</p>
<p>​        所以，传统的脚本化测试（Scripted Testing）方法，即先花一段时间设计测试用例、再依据用例去执行的测试方法，不仅仅对测试设计人员有很高的要求（这里体现了大量的创造性的劳动），同时对测试执行人员也提出了相当高的要求：你得通过测试用例尽可能准确猜测出测试设计人员的心思，还得高于测试设计人员，找到测试用例文字以外的被忽略的但同时也是很重要的信息 －－除非你不想得到更好的测试效果。所以测试执行也是体现了大量的创造性思维的劳动。记得昨日在某一ISTQB-FL课程研讨会上，某位讲师讲到了一页胶片，胶片上赫然把测试执行等之后的环节归为“机械式的活动”，而把之前的一系列测试设计活动归为“创造性活动”，如果你的测试执行都是工具在自动化的做，也许这样分类是说得通的吧。</p>
<p>​        很多组织都过分地看重测试用例，认为测试用例是测试人员最核心的资产，让最优秀的人专职设计测试用例（他们从不或很少做测试执行了），花大量的时间去创建并维护这些用例，这些前端的活动投入非常大。而在最后一段路程，投入反而不那么大了：请一些缺乏经验的测试人员或者干脆雇佣一些对特性不熟的外包人员，依据用例做测试执行即可。当版本发布，用户反馈一些问题后，开始分析这些问题为什么会漏测，准确地说，应该是分析为什么会漏测试设计，因为鲜有人关注测试执行环节能力的提升。人们开始在测试设计阶段运用更多、更复杂的测试设计方法，开始添加更冗长的测试设计流程，开始采用更为详细要求的测试设计模板。。。</p>
<p>​        我时常听到来自测试设计人员的求助，希望我告诉他们“如何才能提升测试用例的有效性？”“如何确保我设计的用例漏测率最低？” 在他们心中，很有责任感地认为：测试漏测，首先是我没有设计好的缘故。我常常会告诉这些测试设计人员：单单依靠测试用例没有必要也不可能发现大部分的bug，很多bug要依赖执行人员在测试执行阶段发现，<strong>这是正常的测试现象</strong>－－你不可能要求盲人通过听得来的对一副画的理解和一个正常人通过看对一副画的理解一致；我不建议测试设计人员长期不做测试执行，不建议测试设计和测试执行的分离，如果你的组织还没有办法做到这一点，请你－－测试设计人员－－一定要时常和测试执行人员沟通，向他请教对你的用例的看法，实时收到反馈信息，调整你的设计；过分重视测试设计而忽视测试执行，就如同“行百里者半九十”一样，最终的测试效果很可能会输在“测试的最后一公里”上。</p>
<p>探索性测试也许就是看中了人在测试中发挥的作用要大于文档在测试中发挥的作用这一点吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/LIMIT%E5%92%8CIFNULL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9ALeetCode-SQL%EF%BC%9ANo.176/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/12/LIMIT%E5%92%8CIFNULL%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9ALeetCode-SQL%EF%BC%9ANo.176/" class="post-title-link" itemprop="url">LIMIT和IFNULL的使用：LeetCode No.176</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-12 01:37:20" itemprop="dateCreated datePublished" datetime="2019-05-12T01:37:20+08:00">2019-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>​        下班在家无聊打开力扣（LeetCode国内版）随便逛逛，突然发现还有SQL题目，随便点开一道简单的题目，平常一般也就用用普通的CURD、分组、排序，多表关联查询什么的，这道题我是没做出来！各位小伙伴看看这道题，大家会不会做～这道题是这样子的：</p>
<p><img src="/images/image-20190512094504177.png" alt="leetcode-sql-176-desc"></p>
<p>看起来普普通通哦，第一反应，排个序嘛～</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(Salary) <span class="keyword">AS</span> SecondHighestSalary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span>;</span></pre></td></tr></table></figure>

<p>再然后就发现卡壳了，触发了我的知识盲区！</p>
<ol>
<li>如何只取出第2行数据？</li>
<li>如何判断是否有第二高的薪水（有可能所有人薪水都一样或空表的情况）？</li>
<li>如何返回null？</li>
</ol>
<p>开始补习功课！</p>
<hr>
<p><em>各种数据库的SQL有一定差异，我们以使用较多的MySQL数据库的SQL语法为例。</em></p>
<h2 id="一、回顾LIMIT子句知识细节"><a href="#一、回顾LIMIT子句知识细节" class="headerlink" title="一、回顾LIMIT子句知识细节"></a>一、回顾LIMIT子句知识细节</h2><p>首先我们回顾下如何限制只返回查询结果的前两行？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> some_col <span class="keyword">FROM</span> some_table <span class="keyword">LIMIT</span> <span class="number">2</span>;</span></pre></td></tr></table></figure>

<p>上述代码使用SELECT语言检索单独的一列数据。LIMIT 2指示MySQL数据库返回不超过2行的数据，其实这就是我们平时最常用的LIMIT子句，但这不是完整的LIMIT子句。</p>
<p>知识点来了！</p>
<h4 id="1-LIMIT子句的完整形态是这样子的："><a href="#1-LIMIT子句的完整形态是这样子的：" class="headerlink" title="1. LIMIT子句的完整形态是这样子的："></a>1. LIMIT子句的完整形态是这样子的：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">LIMIT return_rows_number OFFSET start_index</span></pre></td></tr></table></figure>

<h4 id="2-OFFSET默认值为0："><a href="#2-OFFSET默认值为0：" class="headerlink" title="2. OFFSET默认值为0："></a>2. OFFSET默认值为0：</h4><p>我们上面语句的LIMIT 2其实是LIMIT 2 OFFSET 0的默认简写形式，不显式声明OFFSET值，则OFFSET默认为0。</p>
<h4 id="3-简化版的LIMIT子句："><a href="#3-简化版的LIMIT子句：" class="headerlink" title="3. 简化版的LIMIT子句："></a>3. 简化版的LIMIT子句：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">LIMIT start_index, return_rows_number</span></pre></td></tr></table></figure>

<p>接下来我们实战下看看效果，加深下理解：</p>
<p><img src="/images/image-20190512095326845.png" alt="limit-2-sql-demo-image-20190512095326845"></p>
<p><strong>对于这道题，我们要获取第二行数据，应该这样写</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(Salary) <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>;</span></pre></td></tr></table></figure>

<h2 id="二、回顾IFNULL函数的细节"><a href="#二、回顾IFNULL函数的细节" class="headerlink" title="二、回顾IFNULL函数的细节"></a>二、回顾IFNULL函数的细节</h2><p>MySQL的IFNULL函数其实就是个if else语句，函数语法规则如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">IFNULL(expr1, expr2)</span></pre></td></tr></table></figure>

<p>伪代码逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expr1 == null:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">return</span> expr2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">return</span> expr1;</span></pre></td></tr></table></figure>

<p>执行两条SQL语句实践下更有助于理解：</p>
<p><img src="/images/image-20190512095828594.png" alt="ifnull-sql-demo-image-20190512095828594"></p>
<p>对于我们这道题SQL应该这样写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>((<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(Salary) <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>), <span class="literal">null</span>) <span class="keyword">AS</span> SecondHighestSalary;</span></pre></td></tr></table></figure>

<p>我们来测试下：</p>
<p>1 - 正常的数据，有各种薪资：</p>
<p><img src="/images/image-20190512100622340.png" alt="image-20190512100622340"></p>
<p>2 - 所有人薪水都相同的情况：</p>
<p><img src="/images/image-20190512100717179.png" alt="image-20190512100717179"></p>
<p>3 - 空表的情况：</p>
<p><img src="/images/image-20190512100808599.png" alt="image-20190512100808599"></p>
<p>所有测试通过～</p>
<hr>
<p>这道题虽然标记为简单题目，但是提交通过率却不高，仅有1/3。</p>
<p><img src="/images/image-20190512100927779.png" alt="image-20190512100927779"></p>
<p>说明还是有不少同学和我一样对SQL对掌握不够呀，还是要找时间好好学习使用下。</p>
<p>题目链接在这里：<a href="https://leetcode-cn.com/problems/second-highest-salary/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/second-highest-salary/</a></p>
<p>有兴趣对小伙伴可以试试其他数据库的SQL语句怎么写，欢迎交流讨论。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/08/robotframework%E5%AD%97%E7%AC%A6%E8%BD%AC%E8%AF%91%E4%B9%8B%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/robotframework%E5%AD%97%E7%AC%A6%E8%BD%AC%E8%AF%91%E4%B9%8B%E5%9D%91/" class="post-title-link" itemprop="url">robotframework字符转译之坑</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-08 15:19:16" itemprop="dateCreated datePublished" datetime="2019-04-08T15:19:16+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>去年在公司推广了robotframework自动化框架，基于此框架我们设计开发了HTTPTestLibrary关键字库开展接口测试，效果挺好。我们部门测试开发的统一Python版本为python2.7，因为在我来公司前就在用这个版本，虽然2020年社区不再提供支持，但我们目前还没有迁移Python3的计划，这是前提。</p>
<h1 id="有点别致的JSON"><a href="#有点别致的JSON" class="headerlink" title="有点别致的JSON"></a>有点别致的JSON</h1><p>说到接口测试，必然要支持解析处理各种请求体，其中，我们的研发在某些项目的接口中使用了这样的请求体，我举个例子：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"key1"</span>: <span class="number">123</span>, <span class="attr">"trouble"</span>: <span class="string">"&#123;\"inner\": \"hehe\"&#125;"</span>&#125;</span></pre></td></tr></table></figure>

<p>JSON里嵌套一个JSON对象，还是个字符串型的，这是个标准的JSON类型嘛？？？google得知如下知识</p>
<p><img src="/images/json_org_doc.png" alt="json_org_doc"></p>
<p>我们用Python测试下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: json_str = <span class="string">r'''&#123;"key1": 123, "trouble": "&#123;\"inner\": \"hehe\"&#125;"&#125;'''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: json_str</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Out[<span class="number">9</span>]: <span class="string">'&#123;"key1": 123, "trouble": "&#123;\\"inner\\": \\"hehe\\"&#125;"&#125;'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: print(json_str)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"key1"</span>: <span class="number">123</span>, <span class="string">"trouble"</span>: <span class="string">"&#123;\"inner\": \"hehe\"&#125;"</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="keyword">import</span> json</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: json.loads(json_str)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">Out[<span class="number">12</span>]: &#123;<span class="string">'key1'</span>: <span class="number">123</span>, <span class="string">'trouble'</span>: <span class="string">'&#123;"inner": "hehe"&#125;'</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: type(json.loads(json_str))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">Out[<span class="number">13</span>]: dict</span></pre></td></tr></table></figure>

<p>研发定义的请求体没毛病，接下来看看我们的Python2的robotframework遇到什么问题了。</p>
<h1 id="robotframework测试用例"><a href="#robotframework测试用例" class="headerlink" title="robotframework测试用例"></a>robotframework测试用例</h1><p>我们的robotframework测试用例如下：</p>
<p><img src="/images/rf_test_case.png" alt="rf_test_case"></p>
<p>基于我们对robotframework的了解，robotframework会读取文本格式的robot测试用例，经过解析加载为内存对象，构建测试用例，我们先分别使用Python2和Python3读取测试用例，看看效果是什么样子：</p>
<p><img src="/images/py2_py3_read_rf_case.jpg" alt="py2_py3_read_rf_case"></p>
<p>可以看到，虽然python2和python3对字符串的类型处理方式不同，但是对于我们的测试用例文本，都只进行了转译加上了一个<code>\</code>。</p>
<p>为了方便定位问题，便于观察，我们统一修改了robotframework的源码，增加了文本用例解析的输出</p>
<p><img src="/images/rf_source_code.png" alt="rf_source_code"></p>
<h1 id="Python2版本的robotframework同学登场"><a href="#Python2版本的robotframework同学登场" class="headerlink" title="Python2版本的robotframework同学登场"></a>Python2版本的robotframework同学登场</h1><p>先看下robotframework的测试执行结果，看起来没毛病。</p>
<p><img src="/images/py2_rf_log.png" alt="py2_rf_log"></p>
<p>再看看测试用例的debug输出：</p>
<p><img src="/images/py2_rf_debug.png" alt="py2_rf_debug"></p>
<p>WTF！为神马变成了四个<code>\</code>???，这就是导致我们的请求体异常，接口响应错误的根本原因啊！</p>
<p>可是在上面的的Python2直接读取测试用例表现的不是这样啊！</p>
<p>稳住，我们不能冤枉Python2同学，我们看看Python3的表现。</p>
<h1 id="Python3版本的robot-framework同学低调入场"><a href="#Python3版本的robot-framework同学低调入场" class="headerlink" title="Python3版本的robot framework同学低调入场"></a>Python3版本的robot framework同学低调入场</h1><blockquote>
<p>Python3版本我们使用pipenv创建了一个虚拟环境，同样也修改了robotframework的源码，输出repr</p>
</blockquote>
<p>按惯例先看看Python3版本的robotframework的测试执行结果：</p>
<p><img src="/images/py3_rf_log.png" alt="py3_rf_log"></p>
<p>看起来和python2版本的一模一样，再看看测试用例的debug输出：</p>
<p><img src="/images/py3_rf_debug.png" alt="py3_rf_debug"></p>
<p>一切正常，完美！这样的结果才是我们想要的，这样的结果才能保证我们的接口响应正常。</p>
<h1 id="蛛丝马迹"><a href="#蛛丝马迹" class="headerlink" title="蛛丝马迹"></a>蛛丝马迹</h1><p>我们再仔细阅读下源码，robotframework到底是怎么读取的文本用例：</p>
<p><img src="/images/rf_source_open_mode.png" alt="rf_source_open_mode"></p>
<p>robotframework是以<code>rb</code>模式打开文件进行读取的。</p>
<p>Python官方文档是这么说的：</p>
<blockquote>
<p>通常文件是以 <em>text mode</em> 打开的，这意味着从文件中读取或写入字符串时，都会以指定的编码方式进行编码。如果未指定编码格式，默认值与平台相关 (参见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#open" target="_blank" rel="noopener"><code>open()</code></a>)。在mode 中追加的 <code>&#39;b&#39;</code> 则以 <em>binary mode</em> 打开文件：现在数据是以字节对象的形式进行读写的。这个模式应该用于所有不包含文本的文件。</p>
</blockquote>
<p>但是我们进行debug输出时，python2版本却输出的是<code>&lt;type &#39;str&#39;&gt;</code>类型，python3版本输出的是<code>&lt;class bytes&gt;</code>类型，显然Python2版本的robotframework在搞事情！</p>
<p>Python 3最重要的新特性大概要算是对文本和二进制数据作了更为清晰的区分。文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。Python 3不会以任意隐式的方式混用str和bytes，正是这使得两者的区分特别清晰。</p>
<p>至此，真相逐渐浮出水面了，不过我们还是不知道为什么Python2版本的robotframework会出现这种情况，但我们可以肯定的是，尽早的迁移到Python3，一定是一件正确的事情！</p>
<blockquote>
<p>Reference  </p>
<p><a href="http://www.json.org/json-zh.html" target="_blank" rel="noopener">http://www.json.org/json-zh.html</a><br><a href="https://blog.csdn.net/lgysjfs/article/details/86678559" target="_blank" rel="noopener">https://blog.csdn.net/lgysjfs/article/details/86678559</a><br><a href="http://www.ituring.com.cn/article/1116" target="_blank" rel="noopener">http://www.ituring.com.cn/article/1116</a><br><a href="https://stackoverflow.com/questions/9644110/difference-between-parsing-a-text-file-in-r-and-rb-mode/9644141#9644141" target="_blank" rel="noopener">https://stackoverflow.com/questions/9644110/difference-between-parsing-a-text-file-in-r-and-rb-mode/9644141#9644141</a><br><a href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#reading-and-writing-files" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#reading-and-writing-files</a><br><a href="https://docs.python.org/zh-cn/2.7/tutorial/inputoutput.html#reading-and-writing-files" target="_blank" rel="noopener">https://docs.python.org/zh-cn/2.7/tutorial/inputoutput.html#reading-and-writing-files</a></p>
</blockquote>
<hr>
<p>2019年04月08日 于 南京<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/%E5%BD%93%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%BC%80%E5%A7%8B%E7%94%A8Docker%EF%BC%8C%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/01/%E5%BD%93%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%BC%80%E5%A7%8B%E7%94%A8Docker%EF%BC%8C%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F/" class="post-title-link" itemprop="url">当开发团队开始用Docker，测试团队应该做什么？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-01 12:29:16" itemprop="dateCreated datePublished" datetime="2019-03-01T12:29:16+08:00">2019-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前的<a href="!--￼0--">《Hello Docker》</a>中，简单介绍过Docker，但仅限于在测试开发团队内部使用，或者说更多的是我个人在使用Orz，等了好久终于公司的研发团队开始正式使用Docker了。这次来西安分公司学习下公司基于Docker和K8S开发的容器云平台，深入了解了下Docker的底层原理，简单学习了下K8S的基本概念和操作，感觉对于研发团队来说，容器化的迁移还是有一定成本的。</p>
<h1 id="Docker带来了什么？改变了什么？"><a href="#Docker带来了什么？改变了什么？" class="headerlink" title="Docker带来了什么？改变了什么？"></a>Docker带来了什么？改变了什么？</h1><h2 id="一、传统软件开发流程有几大痛点："><a href="#一、传统软件开发流程有几大痛点：" class="headerlink" title="一、传统软件开发流程有几大痛点："></a>一、传统软件开发流程有几大痛点：</h2><ol>
<li><p>开发、测试、发布环境不统一</p>
</li>
<li><p>配置测试环境过程冗长又复杂</p>
</li>
<li><p>自动化测试环境不稳定，容易受到污染，隔离不足</p>
</li>
<li><p>无法准确获得客户的软件环境</p>
</li>
<li><p>开发团队无法复现测试团队报出的软件缺陷，导致两个团队出现相互推诿的现象</p>
</li>
</ol>
<h2 id="二、当前测试技术面临的几大挑战："><a href="#二、当前测试技术面临的几大挑战：" class="headerlink" title="二、当前测试技术面临的几大挑战："></a>二、当前测试技术面临的几大挑战：</h2><ol>
<li>配置一致的测试环境</li>
<li>快速部署软件</li>
<li>并行执行测试，在并行的同时还要保证测试任务各自的环境不被污染</li>
<li>成功的复现软件缺陷</li>
<li>创建干净的可信的测试环境</li>
<li>快速部署多个测试主机</li>
<li>快速导入测试数据</li>
<li>快速清理测试环境</li>
<li>快速保留、复制、恢复测试环境</li>
<li>正确配置测试工具。快速将测试环境在不同操作系统（类Unix）</li>
</ol>
<h2 id="三、Docker对测试技术的革命性影响"><a href="#三、Docker对测试技术的革命性影响" class="headerlink" title="三、Docker对测试技术的革命性影响"></a>三、Docker对测试技术的革命性影响</h2><p>软件开发交付速度上不去，很大一个问题是软件运行环境这个环节存在瓶颈，Docker解决了这个瓶颈，促进了软件开发的DevOps模式推广，这对所有的软件行业从业者都是巨大利好。</p>
<p>软件测试的几个重要方面：测试策略、测试设计、测试方法、测试数据、测试环境，前三个是方法论思想层面的，后两个是需要技术突破的。测试数据因具体细分行业不同，各有各的痛点也各有各的解决方案，但是对于测试环境来说，Docker是个近乎接近“银弹”的技术解决方案。</p>
<h3 id="通过Docker的软件环境快速部署能力，促进了测试时间的再分配"><a href="#通过Docker的软件环境快速部署能力，促进了测试时间的再分配" class="headerlink" title="通过Docker的软件环境快速部署能力，促进了测试时间的再分配"></a>通过Docker的软件环境快速部署能力，促进了测试时间的再分配</h3><p>一个小小的Dockerfile明确声明了软件部署的所有细节和流程，从此忘记冗长的安装部署文档吧！无论是从研发自测、功能测试、集成测试等哪个环节来讲，测试环境的部署时间成倍缩短，能给工程师更多的时间做更多有意义的事情，开发工程师可以有更多时间完善优化设计，修复缺陷，测试工程师可以有跟多时间拓宽测试的广度和提高测试的深度，运维工程师有更多的时间专注于改进软件监控分析系统，这和有效的自动化测试的价值可以相提并论。</p>
<h3 id="通过Docker的软件环境一致性能力，有效降低了偶然复杂度"><a href="#通过Docker的软件环境一致性能力，有效降低了偶然复杂度" class="headerlink" title="通过Docker的软件环境一致性能力，有效降低了偶然复杂度"></a>通过Docker的软件环境一致性能力，有效降低了偶然复杂度</h3><p>Docker的镜像发布，容器编排运行等设计实现，保证了开发环境、测试环境、生产发布环境以及不同操作系统发行版的高度一致可信，几乎避免了测试团队发现的缺陷在开发环境无法复现、线上生产环境的缺陷在线下无法复现且不便线上调试等问题带来的一些列人力成本、时间成本、心智成本的无谓消耗。</p>
<h3 id="通过Docker的环境隔离管理能力，提高了测试资源的自由度"><a href="#通过Docker的环境隔离管理能力，提高了测试资源的自由度" class="headerlink" title="通过Docker的环境隔离管理能力，提高了测试资源的自由度"></a>通过Docker的环境隔离管理能力，提高了测试资源的自由度</h3><p>以往虽然有各种虚拟化技术，可以一台服务器虚拟化为多台虚拟机，可以对虚拟机进行快照，随时恢复软件环境，但是终究太笨重，资源损耗太高，利用率太低，无法实现测试资源自由。现在有了Docker的资源隔离管理能力，我们可以按照测试需求，启动多个不同版本的服务，随时创建，随时销毁；我们甚至可以在一台服务器给每个测试人员启动一套独立的测试环境，大家并行测试，互不干扰，避免了互相踩踏。同时这种环境资源的自由度，对于自动化测试的执行过程是有很大帮助的，大大提高了自动化测试的成功率，进而提高自动化测试的ROI。</p>
<h1 id="测试团队如何顺势而为？"><a href="#测试团队如何顺势而为？" class="headerlink" title="测试团队如何顺势而为？"></a>测试团队如何顺势而为？</h1><p>上一小节总结的三点革命性影响，对于整个开发流程来说，已经为CI/CD提供了道路基石，势必将进一步缩短迭代周期，提高交付速度（虽然还是有需求变更，开发延期等软件开发管理上不可避免的问题和人的不可靠性等因素等debuff）</p>
<p>效率提高了，交付速度提高了，迭代速度更快了，单纯的手工测试已经跟不上DevOps的软件开发模式了（其实在很多年前就跟不上现代软件开发节奏了），对测试的要求更高了，应当思考下省下来的时间如何更好的利用，如何跟上研发提测的速度。对于我现在所在的这种相对传统的行业软件服务企业来说，测试团队必须尽快适应这种DevOps开发模式了，不然就会被历史的车轮碾死在尘埃里。</p>
<p>测试团队的核心职责是质量保障，围绕质量保障，我们可以将测试能力向前向后输出，输出的最好形式就是自动化。</p>
<ul>
<li>自动化测试环境资源不再是自动化实施的绊脚石，接下来需要考验的是我们的自动化框架、自动化工具是否真的可靠、可用。</li>
<li>测试驱动开发的模式虽然很好，但是推广落地却不是那么容易的😊。<strong>测试团队还可以将测试用例封装为自动化测试服务，提供给研发自测</strong>，而不是等研发一次次快速提测再被打回，冲击消耗测试工程师的激情和精力。更近一步可以考虑通过<strong>感知镜像仓库中镜像的变化，动态触发自动化测试</strong>。当然长远看来还是要与开发团队共同实现CI/CD，需要各个研发部门通力合作。</li>
<li>软件运行环境的高度一致性，理论上线上发现的缺陷可以等价于测试团队漏测，这对测试团队的可信度和口碑是一个挑战，需要进一步提高测试质量和标准</li>
<li>上线后的软件运行状态检测，虽然按照传统分工应当是运维团队来做的，但是测试团队在这方面也有自己得天独厚的优势，对产品的深刻理解，测试角度，可以将内测测试用例调整转为适配线上数据环境的在线自动化测试用例，实现线上测试，在第一时间发现由于线上环境测试数据的多样性和量级带来的问题，及时收集触发线上自动化用例失败的测试数据来完善测试用例库，提高测试覆盖度。</li>
</ul>
<p>总而言之，核心就是<strong>进一步提高自动化测试技术的深度和广度</strong>。</p>
<p>暂时想到这些，有新的想法再补充。</p>
<blockquote>
<p>Reference<br><a href="https://www.infoq.cn/article/docker-lead-test-innovation" target="_blank" rel="noopener">https://www.infoq.cn/article/docker-lead-test-innovation</a></p>
</blockquote>
<hr>
<p>2019年03月01日 于 西安<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a>    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" class="post-title-link" itemprop="url">程序员的自我修养</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-02-28 14:08:32" itemprop="dateCreated datePublished" datetime="2019-02-28T14:08:32+08:00">2019-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h1><blockquote>
<p>摘自“隔壁王校长”的《<a href="https://www.imooc.com/learn/602" target="_blank" rel="noopener">Go语言框架：Beego vs Gin</a>》</p>
</blockquote>
<h2 id="原则一："><a href="#原则一：" class="headerlink" title="原则一："></a>原则一：</h2><p>一切语言、技术或者框架，本质都是工具，工具的价值在于为使用者提供竞争优势。</p>
<h2 id="原则二："><a href="#原则二：" class="headerlink" title="原则二："></a>原则二：</h2><p>如果真的有一种语言或者框架很牛逼，那么荣耀或者赞誉也应该属于创造它的人，与使用者没有半毛钱关系；<strong>使用者的荣耀应该来自：针对恰当的需求使用恰当的语言或框架，并且做到按时交付以及高质量</strong>。</p>
<h2 id="原则三："><a href="#原则三：" class="headerlink" title="原则三："></a>原则三：</h2><p>大部分人并不是天生具有选择恐惧症，也不是天生的杠精，在我看来所有关于选择的迷惑或者争吵，大都因为：</p>
<ul>
<li>没有设定清晰的标准</li>
<li>标准不唯一</li>
<li>标准之间没有优先级或者权重</li>
</ul>
<hr>
<p>2019年02月28日 于 西安<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/05/Hello-Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/05/Hello-Docker/" class="post-title-link" itemprop="url">Hello Docker</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-05 04:08:32" itemprop="dateCreated datePublished" datetime="2019-01-05T04:08:32+08:00">2019-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>说起来Docker，大家都或多或少有耳闻，但是我的公司因为业务场景，长尾效应，至今为止Docker只在小部分项目轻度使用。但是这不妨碍我们主动学习，应用Docker，因此，从2018年开始，我就推动Docker在测试部应用。我们的测试平台，GitLab、JIRA、Confluence等都是通过Docker部署的。</p>
<p>团队内部做算法测试的同学搭建开发测试环境需要安装各种第三方库，因为工作环境是内网，无法连接互联网进行安装，痛苦不堪，使用Docker将相关环境在外网构建好传入内网使用是比较方便的方式；还有工具链建设、测试平台建设用到的各种基础设施MySQL、Nginx等快速部署，使用Docker都是最佳方案。为了方便团队同学了解Docker，团队老大让我来进行一次内部Docker入门分享。</p>
<h1 id="没有Docker的从前"><a href="#没有Docker的从前" class="headerlink" title="没有Docker的从前"></a>没有Docker的从前</h1><p>为了提高服务器利用效率，我们将一台高性能的服务器通过vSphere虚拟化，创建多台虚拟机，提供相对独立环境隔离的操作系统环境和计算资源，我们可以对每一台虚拟机灵活分配计算资源、存储资源等，还可以对每一台虚拟机创建多个快照，看起来很棒！是的，在传统的软件开发模式下，这种方式挺好，但是这并没有解决软件的部署效率低，交付困难，开发环境与测试环境不一致，测试环境与生产环境不一致等问题，这也是为什么我们有了持续集成，却没有做好持续交付的一大根本问题。</p>
<h1 id="有了Docker的现在"><a href="#有了Docker的现在" class="headerlink" title="有了Docker的现在"></a>有了Docker的现在</h1><p>各大互联网厂商都在使用Docker，通过Docker结合微服务等技术他们将DevOps这一理念落地了，真正做到了持续集成、持续部署、持续交付，快速迭代，可以实现一天多次版本上线发布！回头看有了Docker我们在日常工作中能做什么，举个最简单的例子：</p>
<p>以往我们想部署三套环境（一套Dev环境、一套Test环境、一套Release环境），需要三个MySQL数据库，需要怎么做呢？</p>
<ul>
<li>方案1：准备三台服务器，分别安装MySQL，干干净净，互不干扰，但是浪费资源啊；</li>
<li>方案2：一台服务器部署三个MySQL实例，分别配置不同的MySQL数据存储路径、配置文件路径、端口，操作复杂，维护困难，想想都头疼；</li>
</ul>
<p>用Docker以后呢，我们可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker run --name release-mysql -p 3306:3306 -d mysql:5.7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">docker run --name dev-mysql -p 3307:3306 -d mysql:5.7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">docker run --name test-mysql -p 3308:3306 -d mysql:5.7</span></pre></td></tr></table></figure>

<p>这样我们就有了三个独立的MySQL数据库服务！当然这是个示例，没有做数据卷映射等配置，但那些配置相比于传统方案来说，复杂度不值一提。</p>
<h1 id="Docker到底是什么"><a href="#Docker到底是什么" class="headerlink" title="Docker到底是什么"></a>Docker到底是什么</h1><p>Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。</p>
<h2 id="什么是容器呢？"><a href="#什么是容器呢？" class="headerlink" title="什么是容器呢？"></a>什么是容器呢？</h2><blockquote>
<h2 id="将软件打包成标准化单元，以用于开发、交付和部署"><a href="#将软件打包成标准化单元，以用于开发、交付和部署" class="headerlink" title="将软件打包成标准化单元，以用于开发、交付和部署"></a>将软件打包成标准化单元，以用于开发、交付和部署</h2></blockquote>
<p>容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</p>
<h3 id="容器的优势特点"><a href="#容器的优势特点" class="headerlink" title="容器的优势特点"></a>容器的优势特点</h3><h4 id="轻量"><a href="#轻量" class="headerlink" title="轻量"></a>轻量</h4><p>在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p>
<h4 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h4><p>Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p>
<h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><p>Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p>
<h3 id="容器-VS-虚拟机"><a href="#容器-VS-虚拟机" class="headerlink" title="容器 VS 虚拟机"></a>容器 VS 虚拟机</h3><p>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。与虚拟机相比，容器占用的空间较少（容器镜像大小通常只有几十兆），瞬间就能完成启动。</p>
<p><img src="/images/Container@2x.png" alt="Container@2x"></p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此占用大量空间。而且 VM 启动也十分缓慢。</p>
<p><img src="/images/VM@2x.png" alt="VM@2x"></p>
<h4 id="对比传统虚拟机总结"><a href="#对比传统虚拟机总结" class="headerlink" title="对比传统虚拟机总结"></a>对比传统虚拟机总结</h4><table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 <code>MB</code></td>
<td>一般为 <code>GB</code></td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h3 id="容器和虚拟机共用"><a href="#容器和虚拟机共用" class="headerlink" title="容器和虚拟机共用"></a>容器和虚拟机共用</h3><p>将容器和虚拟机配合使用，为应用的部署和管理提供极大的灵活性。</p>
<p><img src="/images/containers-vms-together.png" alt="containers-vms-together"></p>
<h1 id="如何使用Docker"><a href="#如何使用Docker" class="headerlink" title="如何使用Docker"></a>如何使用Docker</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Docker可以安装在Linux、Mac、Window上面，但是需要注意的是，Unix安装Docker（Linux、Mac）上对操作系统内核版本有要求（RedHat要7UX以上版本），Windows安装Docker推荐使用Win10操作系统（Win7也不是不能装，太折腾，人生苦短）。</p>
<p>具体安装方式Google搜一下就很多，不罗嗦了。</p>
<h2 id="年轻人的第一个Docker命令"><a href="#年轻人的第一个Docker命令" class="headerlink" title="年轻人的第一个Docker命令"></a>年轻人的第一个Docker命令</h2><p><img src="/images/1546666360155.png" alt="1546666360155"></p>
<p>我们看下这条<code>docker run hello-world</code>命令执行后发生了什么：</p>
<ul>
<li>本地没有找到<code>hello-world:latest</code>这个<code>镜像</code>，通过<code>pull</code>命令从docker的<code>仓库</code>一个最新的<code>镜像</code></li>
<li>下载完毕后启动了<code>hello-world</code>的<code>容器</code>，输出了一段介绍Docker的信息</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker包括三个基本概念</p>
<ul>
<li>镜像（<code>Image</code>）</li>
<li>容器（<code>Container</code>）</li>
<li>仓库（<code>Repository</code>）</li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h3 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h3><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href="https://yeasy.gitbooks.io/docker_practice/content/data_management/volume.html" target="_blank" rel="noopener">数据卷（Volume）</a>、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h4 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h4><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="http://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 <a href="https://yeasy.gitbooks.io/docker_practice/content/install/mirror.html" target="_blank" rel="noopener">安装 Docker</a> 一节中有详细的配置方法。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p>
<h4 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h4><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a>镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbooks.io/docker_practice/content/repository/registry.html" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a> 和 <a href="https://www.sonatype.com/docker" target="_blank" rel="noopener">Sonatype Nexus</a>。</p>
<h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><p>在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。</p>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>之前提到过，<a href="https://hub.docker.com/explore/" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span></pre></td></tr></table></figure>

<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li>
<li>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
</ul>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">18.04: Pulling from library/ubuntu</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">bf5d46315322: Pull complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">9f13e0ac480c: Pull complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">e8988b5b3097: Pull complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">40af181810e7: Pull complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">e6f7c7e5c03e: Pull complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span></pre></td></tr></table></figure>

<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ubuntu:18.04 \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">NAME=<span class="string">"Ubuntu"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">VERSION=<span class="string">"18.04.1 LTS (Bionic Beaver)"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ID=ubuntu</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ID_LIKE=debian</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">PRETTY_NAME=<span class="string">"Ubuntu 18.04.1 LTS"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">VERSION_ID=<span class="string">"18.04"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">HOME_URL=<span class="string">"https://www.ubuntu.com/"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">SUPPORT_URL=<span class="string">"https://help.ubuntu.com/"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.launchpad.net/ubuntu/"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">PRIVACY_POLICY_URL=<span class="string">"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">VERSION_CODENAME=bionic</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">UBUNTU_CODENAME=bionic</span></pre></td></tr></table></figure>

<p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbooks.io/docker_practice/content/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p>
<p>最后我们通过 <code>exit</code> 退出了这个容器。</p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker images</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:/home/evi1<span class="comment"># docker images</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">evi1/pypiserver         1.2.5               be7e6669fce0        37 hours ago        88.5MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">hello-world             latest              fce289e99eb9        4 days ago          1.84kB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&lt;none&gt;                  &lt;none&gt;              00285df0df87        5 days ago          342 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">nginx                   latest              02256cfb0e4b        9 days ago          109MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">alpine                  3.7                 9bea9e12e381        2 weeks ago         4.21MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ubuntu                  18.04               f753707788c5        4 weeks ago         127 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ubuntu                  latest              f753707788c5        4 weeks ago         127 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">mysql                   5.7                 ae6b78bedf88        7 weeks ago         372MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">pypiserver/pypiserver   v1.2.5              b26b8ee831d7        7 weeks ago         86MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">codekoala/pypi          latest              f6ab585f84ed        7 months ago        61.3MB</span></pre></td></tr></table></figure>

<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>127 MB</code>，但是在 <a href="https://hub.docker.com/r/library/ubuntu/tags/" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>50 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;home&#x2F;evi1# docker system df</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Images              13                  2                   1.931GB             1.614GB (83%)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Containers          2                   1                   2B                  0B (0%)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Local Volumes       14                  0                   0B                  0B</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Build Cache         0                   0                   0B                  0B</span></pre></td></tr></table></figure>

<h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span></pre></td></tr></table></figure>

<p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image ls -f dangling=<span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</span></pre></td></tr></table></figure>

<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image prune</span></pre></td></tr></table></figure>

<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span></pre></td></tr></table></figure>

<h4 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<p>比如我们有这么一些镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY                  TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">centos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">redis                       alpine              501ad78535f0        3 weeks ago         21.03 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">docker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">nginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</span></pre></td></tr></table></figure>

<p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image rm 501</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Untagged: redis:alpine</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span></pre></td></tr></table></figure>

<p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image rm centos</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Untagged: centos:latest</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span></pre></td></tr></table></figure>

<p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker image ls --digests</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">node                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span></pre></td></tr></table></figure>

<h3 id="导出和导入镜像"><a href="#导出和导入镜像" class="headerlink" title="导出和导入镜像"></a>导出和导入镜像</h3><p>根据我们公司的工作环境，互联网隔绝，必然要从外网下载或构建好镜像传入内网使用</p>
<p>下面我们就以<code>evi1/pypiserver:1.2.5</code>这个镜像为例演示下</p>
<p>首先我们在外网查看下镜像信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# docker images</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">evi1&#x2F;pypiserver         1.2.5               be7e6669fce0        38 hours ago        88.5MB</span></pre></td></tr></table></figure>

<h4 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h4><p>通过<code>docker save</code>命令来执行导出镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# docker save --help</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Usage:	docker save [OPTIONS] IMAGE [IMAGE...]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Options:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span></pre></td></tr></table></figure>

<p>针对我们这里的镜像，命令应如下书写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# docker save -o evi1-pypiserver_1.2.5.tar evi1&#x2F;pypiserver:1.2.5</span></pre></td></tr></table></figure>

<p>此处注意几点：</p>
<ul>
<li><p>save -o 后面的参数是我们要保存的文件, 我们约定使用<code>.tar</code>结尾，此时导出的文件是为压缩的文件</p>
</li>
<li><p>tar文件我们按照<code>{用户名}-{镜像名}_{标签}.tar</code>格式来命名，这样方便管理，统一格式</p>
</li>
<li><p>镜像参数我们使用镜像名称+标签的方式，这样有一个好处，导入后的镜像自带名称和标签，无需手动命名，否则导入的镜像会显示为如下样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;none&gt;              &lt;none&gt;              be7e6669fce0        38 hours ago        88.5MB</span></pre></td></tr></table></figure>

</li>
</ul>
<p>至此我们就可以将镜像传入内网了，但是这个文件导出后大小为<code>88.5MB</code>，我们还可以压缩下，加快传输速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# tar czvf evi1-pypiserver_1.2.5.tar.gz evi1-pypiserver_1.2.5.tar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">evi1-pypiserver_1.2.5.tar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# du -sh *</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">89M	evi1-pypiserver_1.2.5.tar</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">33M	evi1-pypiserver_1.2.5.tar.gz</span></pre></td></tr></table></figure>

<p>看到文件压缩后大小仅为原始镜像的1/3，所以大家从外网拉取镜像时要保持压缩的好习惯</p>
<h4 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h4><p>镜像压缩包被传入内网后，我们先将压缩包上传至Docker所在的服务器任意目录下（通常我们会建立一个目录专门存放各种镜像压缩包，也便于我们后续建立私有镜像仓库，统一管理）</p>
<p>第一步先解压镜像压缩包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# tar zxvf pypiserver_1.2.5.tar.gz</span></pre></td></tr></table></figure>

<p>解压后我们得到一个<code>evi1-pypiserver_1.2.5.tar</code>文件</p>
<p>接下里开始真正的导入镜像操作<code>docker load</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# docker load --help</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Usage:	docker load [OPTIONS]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Load an image from a tar archive or STDIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">Options:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  -i, --input string   Read from tar archive file, instead of STDIN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  -q, --quiet          Suppress the load output</span></pre></td></tr></table></figure>

<p>针对我们这里的镜像，命令应如下书写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@evi1-book:&#x2F;tmp&#x2F;docker_images# docker load &lt; evi1-pypiserver_1.2.5.tar</span></pre></td></tr></table></figure>

<p>然后我们通过<code>docker image ls</code>就能看到导入的镜像了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@xxxx:&#x2F;home&#x2F;root# docker image ls evi1&#x2F;pypiserver</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">evi1&#x2F;pypiserver     1.2.5               be7e6669fce0        38 hours ago        88.5MB</span></pre></td></tr></table></figure>




<h2 id="操作-Docker-容器"><a href="#操作-Docker-容器" class="headerlink" title="操作 Docker 容器"></a>操作 Docker 容器</h2><p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>stopped</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h4 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h4><p>所需要的命令主要为 <code>docker run</code>。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/<span class="built_in">echo</span> <span class="string">'Hello world'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Hello world</span></pre></td></tr></table></figure>

<p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:18.04 /bin/bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment">#</span></span></pre></td></tr></table></figure>

<p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment"># pwd</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">/</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:/<span class="comment"># ls</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span></pre></td></tr></table></figure>

<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:/<span class="comment"># ps</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  PID TTY          TIME CMD</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    1 ?        00:00:00 bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   11 ?        00:00:00 ps</span></pre></td></tr></table></figure>

<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr></table></figure>

<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 <code>-d</code> 参数运行容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:18.04 /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span></pre></td></tr></table></figure>

<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p>
<p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker container ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">77b2dc01fe0f  ubuntu:18.04  &#x2F;bin&#x2F;sh -c &#39;while tr  2 minutes ago  Up 1 minute        agitated_wright</span></pre></td></tr></table></figure>

<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker container logs [container ID or NAMES]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">hello world</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">. . .</span></pre></td></tr></table></figure>

<h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">docker container ls -a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ba267838cc1b        ubuntu:18.04             <span class="string">"/bin/bash"</span>            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">98e5efa7d997        training/webapp:latest   <span class="string">"python app.py"</span>        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span></pre></td></tr></table></figure>

<p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p>
<p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p>
<h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ docker container ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">243c32535da7        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">$ docker attach 243c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">root@243c32535da7:/<span class="comment">#</span></span></pre></td></tr></table></figure>

<p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><h5 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a>-i -t 参数</h5><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p>
<p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -dit ubuntu</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ docker container ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">69d137adef7a        ubuntu:latest       <span class="string">"/bin/bash"</span>         18 seconds ago      Up 17 seconds                           zealous_swirles</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -i 69d1 bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">bin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">boot</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">dev</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 69d1 bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">root@69d137adef7a:/<span class="comment">#</span></span></pre></td></tr></table></figure>

<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p>
<p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p>
<h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h4 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker container ls -a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">7691a814370e        ubuntu:18.04        <span class="string">"/bin/bash"</span>         36 hours ago        Exited (0) 21 hours ago                       <span class="built_in">test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar</span></pre></td></tr></table></figure>

<p>这样将导出容器快照到本地文件。</p>
<h4 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | docker import - <span class="built_in">test</span>/ubuntu:v1.0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$ docker image ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span></pre></td></tr></table></figure>

<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker import http://example.com/exampleimage.tgz example/imagerepo</span></pre></td></tr></table></figure>

<p><em>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker container rm  trusting_newton</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">trusting_newton</span></pre></td></tr></table></figure>

<p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p>
<h4 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker container prune</span></pre></td></tr></table></figure>

<h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<h4 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h4><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 <code>docker logout</code> 退出登录。</p>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<p>例如以 <code>centos</code> 为关键词进行搜索：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker search centos</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span></pre></td></tr></table></figure>

<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 <code>tianon/centos</code> 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p>
<p>下载官方 <code>centos</code> 镜像到本地。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker pull centos</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">Pulling repository centos</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">0b443ba03958: Download complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">539c0211cd76: Download complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">511136ea3c5a: Download complete</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">7064731afe90: Download complete</span></pre></td></tr></table></figure>

<h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:18.04 username/ubuntu:18.04</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$ docker image ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">username/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">$ docker push username/ubuntu:18.04</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">$ docker search username</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">username/ubuntu</span></pre></td></tr></table></figure>

<h2 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h2><p><img src="/images/types-of-mounts.png" alt="types-of-mounts"></p>
<p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p>
</blockquote>
<h4 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker volume create my-vol</span></pre></td></tr></table></figure>

<p>查看所有的 <code>数据卷</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker volume ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span>               my-vol</span></pre></td></tr></table></figure>

<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker volume inspect my-vol</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Driver"</span>: <span class="string">"local"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Mountpoint"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Name"</span>: <span class="string">"my-vol"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Options"</span>: &#123;&#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="string">"Scope"</span>: <span class="string">"local"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr></table></figure>

<h4 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    --name web \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># -v my-vol:/wepapp \</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    --mount <span class="built_in">source</span>=my-vol,target=/webapp \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    training/webapp \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    python app.py</span></pre></td></tr></table></figure>

<h4 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span></pre></td></tr></table></figure>

<p><code>数据卷</code> 信息在 “Mounts” Key 下面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">"Mounts": [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Type"</span>: <span class="string">"volume"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Name"</span>: <span class="string">"my-vol"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/var/lib/docker/volumes/my-vol/_data"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/app"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Driver"</span>: <span class="string">"local"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">],</span></pre></td></tr></table></figure>

<h4 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker volume rm my-vol</span></pre></td></tr></table></figure>

<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker volume prune</span></pre></td></tr></table></figure>

<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><h4 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    --name web \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp \</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    training/webapp \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    python app.py</span></pre></td></tr></table></figure>

<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run -d -P \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    --name web \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># -v /src/webapp:/opt/webapp:ro \</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/src/webapp,target=/opt/webapp,<span class="built_in">readonly</span> \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    training/webapp \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    python app.py</span></pre></td></tr></table></figure>

<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">/opt/webapp <span class="comment"># touch new.txt</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">touch: new.txt: Read-only file system</span></pre></td></tr></table></figure>

<h4 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker inspect web</span></pre></td></tr></table></figure>

<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">"Mounts": [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Type"</span>: <span class="string">"bind"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Source"</span>: <span class="string">"/src/webapp"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Destination"</span>: <span class="string">"/opt/webapp"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Mode"</span>: <span class="string">""</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"RW"</span>: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="attr">"Propagation"</span>: <span class="string">"rprivate"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">],</span></pre></td></tr></table></figure>

<h4 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">   <span class="comment"># -v $HOME/.bash_history:/root/.bash_history \</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=<span class="variable">$HOME</span>/.bash_history,target=/root/.bash_history \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   ubuntu:18.04 \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   bash</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">root@2affd44b4667:/<span class="comment"># history</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">1  ls</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">2  diskutil list</span></pre></td></tr></table></figure>

<p>这样就可以记录在容器输入过的命令了。</p>
<blockquote>
<p>Reference </p>
<p><a href="https://www.docker-cn.com" target="_blank" rel="noopener">https://www.docker-cn.com</a></p>
<p><a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/25/%E6%97%A0%E5%BA%8F%E5%A4%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/25/%E6%97%A0%E5%BA%8F%E5%A4%A7%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">无序大数组的中位数算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-25 21:29:10" itemprop="dateCreated datePublished" datetime="2018-05-25T21:29:10+08:00">2018-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h1><p>最近做了一道题，题目是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">找到一个巨大数组的中位数。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"># demo：[1,100,2,5,12,44,88,77,54,932,61]</span></pre></td></tr></table></figure>

<h1 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h1><p>巨大的数组，排序肯定不是最优解了，解题思路可以借鉴快排算法那种分而治之的思想。</p>
<p>详情直接看代码实现吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># author: toddler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> statistics</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">sys.setrecursionlimit(<span class="number">1000000</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_mid</span><span class="params">(mid_index, __list)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="string">    寻找中位数算法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :param mid_index: 中位数索引</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :param __list: 目标数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :return: 中位数数值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="string">    """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 随机取一个数作为分割元素, 以分割元素为界限，将数组分割大小两部分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    random_num = random.choice(__list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    small_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> __list <span class="keyword">if</span> i &lt; random_num]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 若小数组的右端索引大于中位数索引, 则继续缩小小数组的区间长度, 这样可以直接舍弃比中位数大的元素, 减少计算量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> len(small_list) &gt; mid_index:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> find_mid(mid_index, small_list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 分割点左边的元素没有价值, 被舍弃, 相应的中位数索引左移对应长度, 保证相对原始数据索引长度不变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    mid_index -= len(small_list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 判断分割点有几个, 若分割点所占空间长度大于新的中位数索引, 则分割点就是中位数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    same_mid_num = __list.count(random_num)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> same_mid_num &gt; mid_index:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> random_num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 接下来向右计算, 所以切分点所占据的索引区间元素将不在计算, 大数组将舍弃这些值, 因此调整中位数的索引值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    mid_index -= same_mid_num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    big_list = [i <span class="keyword">for</span> i <span class="keyword">in</span> __list <span class="keyword">if</span> i &gt; random_num]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> find_mid(mid_index, big_list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(__list)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="string">    调度处理算法无关的业务逻辑</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :param __list: 目标数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :return: 中位数数值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="string">    """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    list_length = len(__list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> list_length != <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 判断奇数个还是偶数个</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> list_length % <span class="number">2</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">            mid_index = list_length // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">            print(<span class="string">"奇数个数字: &#123;&#125;"</span>.format(list_length))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> find_mid(mid_index, __list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">            print(<span class="string">"偶数个数字: &#123;&#125;"</span>.format(list_length))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            left_num = find_mid((list_length - <span class="number">1</span>) // <span class="number">2</span>, __list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">            right_num = find_mid((list_length + <span class="number">1</span>) // <span class="number">2</span>, __list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> (left_num + right_num) / <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"输入列表是否为空"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(test_data)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="string">    测试验证</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :param test_data: 待测数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"><span class="string">    :return:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"><span class="string">    """</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># print('原始数据: &#123;&#125;'.format(test_data))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    stand_s_time = time.clock()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    expect_mid = statistics.median(test_data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    stand_e_time = time.clock()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">"statistics计算耗时: &#123;&#125;"</span>.format(stand_e_time - stand_s_time))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    start_time = time.clock()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    actual_mid = run(test_data)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    end_time = time.clock()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">"我的算法计算耗时: &#123;&#125;"</span>.format(end_time-start_time))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">'期望结果: 中位数为&#123;&#125;'</span>.format(expect_mid))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">'实际结果: 中位数为&#123;&#125;'</span>.format(actual_mid))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">assert</span> expect_mid == actual_mid, <span class="string">'计算错误'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">demo_list = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">44</span>, <span class="number">88</span>, <span class="number">77</span>, <span class="number">54</span>, <span class="number">932</span>, <span class="number">61</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">print(<span class="string">'样例测试=====&gt;'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">test(demo_list)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">print(<span class="string">'\r\n大数据量测试======&gt;'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">test([random.randint(<span class="number">0</span>, int(<span class="number">1e6</span>)) <span class="keyword">for</span> _ <span class="keyword">in</span> range(int(<span class="number">1e6</span>))])</span></pre></td></tr></table></figure>

<h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>测试环境：</p>
<table>
<thead>
<tr>
<th align="center">硬件</th>
<th align="center">指标</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CPU</td>
<td align="center">Intel(R) Core(TM) i3-4370 CPU @ 3.80GHz</td>
</tr>
<tr>
<td align="center">MEM</td>
<td align="center">8G DDR3</td>
</tr>
</tbody></table>
<p>算法表现，稳定性不是很好：</p>
<table>
<thead>
<tr>
<th align="center">数据量</th>
<th align="center">排序时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10 ^ 6</td>
<td align="center">0.5 s</td>
</tr>
<tr>
<td align="center">10 ^ 7</td>
<td align="center">5 ~ 6 s</td>
</tr>
<tr>
<td align="center">10 ^ 8</td>
<td align="center">65 ~ 100 s</td>
</tr>
</tbody></table>
<h1 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h1><table>
<thead>
<tr>
<th align="center">最差时间分析</th>
<th align="center">平均时间复杂度</th>
<th align="center">稳定度</th>
<th align="center">空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">O(n)</td>
<td align="center">O(logn)</td>
<td align="center">不稳定</td>
<td align="center">O(logn)</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/07/%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">微信跳一跳之线性回归算法优化</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-01-07 12:24:53" itemprop="dateCreated datePublished" datetime="2018-01-07T12:24:53+08:00">2018-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%B8%B8%E6%88%8F/" itemprop="url" rel="index">
                    <span itemprop="name">游戏</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近微信上线了一款小应用—“跳一跳”，这个规则简单，让人上瘾的小游戏和2048一样魔性，朋友圈也是各路小伙伴各显神通：硬件流（树莓派+步进电机）、日天流（篡改http请求）、软件流（adb控制手机模拟点击）。</p>
<p>今天我们也来实践下，当然选择最顺手的Python来搞咯，直接找到开源项目<a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">wechat_jump_game</a>进行优化改造。此项目有个pull request<a href="https://github.com/wangshub/wechat_jump_game/pull/825" target="_blank" rel="noopener">[优化]跑分17000+ 新增AI模块，机器人自主学习生成跳跃公式</a>，看到AI我们就来了兴趣，只见过理论，还没有实践过，可以拿这个实践下。</p>
<p>这个pull request介绍如下：</p>
<blockquote>
<p>机器人精确采集跳跃结果并自主学习，使用线性回归方法<br>拟合出最优 [按压时间]-&gt;[弹跳距离] 线性公式 Y =kX + b<br>本优化无需修改config文件，可以适配所有手机，经过十次以上跳跃学习，机器人即可<br>模拟出相对稳定的线性公式。随着采集结果越多，跳跃也越精确，后期基本连续命中靶心。<br>理论上只要目标点获取无误，会一直跳下去。</p>
</blockquote>
<p>工作两年多，一直在做服务端后台应用相关的测试，没接触过移动端测试呢，正好趁这次机会学习下怎么通过代码自动化控制安卓手机。<br>下面来动手试一下，找出下岗多年的MX3，充电开机。</p>
<h1 id="第一次调试"><a href="#第一次调试" class="headerlink" title="第一次调试"></a>第一次调试</h1><ol>
<li>安装好adb，配置好环境变量。</li>
<li>手机打开开发者模式，连接PC。</li>
<li>命令行测试是否连接成功: adb devices，手机弹出是否信任窗口，点击确定，已经链接成功。</li>
<li>测试一些adb命令是否正常: adb shell wm size，返回信息：Physical size: 1080x1800，完美。</li>
<li>通过virtualenv建立虚拟环境，安装项目所需的第三方库。</li>
<li>手机微信打开跳一跳，点击开始游戏。</li>
<li>运行wechat_jump_auto_ai.py，报错T_T…<br> 查看代码发现是截图部分操作不适配MX3，手动修改代码后成功截图运行<br> 将 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">screenshot = screenshot.replace(<span class="string">b'\r\n'</span>, <span class="string">b'\n'</span>)</span></pre></td></tr></table></figure>
 修改为 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">screenshot = screenshot.replace(<span class="string">b'\r\r\n'</span>, <span class="string">b'\n'</span>)</span></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="第二次调试"><a href="#第二次调试" class="headerlink" title="第二次调试"></a>第二次调试</h1><p>按照程序逻辑，运行十次之后即可采用线性回归算法学习得到的公式，根据已知距离得出按压时间，但实际结果却和一个弱智一样，2分就挂掉了…<br>查看代码发现有个魔法数字要自己设置，程序根据这个数字进行截图计算误差:time.sleep(0.2)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在跳跃落下的瞬间 摄像机移动前截图 这个参数要自己校调</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">time.sleep(<span class="number">0.2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">pull_screenshot_temp()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">im_temp = Image.open(<span class="string">'./autojump_temp.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">temp_piece_x, temp_piece_y = find_piece(im_temp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">debug.computing_error(press_time, board_x, board_y, piece_x, piece_y, temp_piece_x, temp_piece_y)</span></pre></td></tr></table></figure>

<p>经过debug截图不断调整，得出我的PC和MX3配合的最佳数值是0.04。<br>删除学习数据jump_range.csv，重新开始训练，程序终于能磕磕绊绊达到400分左右，但是大概需要1小时左右，对学习数据通过pandas和matplotlib进行绘图，看到训练采集到的数据离散程度很高，明显学习效果不佳。</p>
<h1 id="第三次调试（重点）"><a href="#第三次调试（重点）" class="headerlink" title="第三次调试（重点）"></a>第三次调试（重点）</h1><p>再次阅读代码，发现这个AI版本的代码有瑕疵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computing_error</span><span class="params">(last_press_time, target_board_x, target_board_y, last_piece_x, last_piece_y, temp_piece_x, temp_piece_y)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="string">	计算跳跃实际误差</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="string">	"""</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	target_distance = math.sqrt(abs(target_board_x - last_piece_x) ** <span class="number">2</span> + abs(target_board_y - last_piece_y) ** <span class="number">2</span>)  <span class="comment"># 上一轮目标跳跃距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	actual_distance = math.sqrt(abs(temp_piece_x - last_piece_x) ** <span class="number">2</span> + abs(temp_piece_y - last_piece_y) ** <span class="number">2</span>)  <span class="comment"># 上一轮实际跳跃距离</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	jump_error_value = math.sqrt(abs(target_board_x - temp_piece_x) ** <span class="number">2</span> + abs(target_board_y - temp_piece_y) ** <span class="number">2</span>)  <span class="comment"># 跳跃误差</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">print</span> <span class="string">"目标距离: &#123;0&#125;, 实际距离: &#123;1&#125;, 误差距离: &#123;2&#125;, 蓄力时间: &#123;3&#125;ms"</span>.format(round(target_distance), round(actual_distance), round(jump_error_value), round(last_press_time))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># 将结果采集进学习字典</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> last_piece_x &gt; <span class="number">0</span> <span class="keyword">and</span> last_press_time &gt; <span class="number">0</span> :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		ai.add_data(round(actual_distance, <span class="number">2</span>), round(last_press_time))</span></pre></td></tr></table></figure>
<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>target_distance与actual_distance有可能会等于0.0或者一个超出实际范围的值，这些值会在游戏失败重新开始时出现，原程序没有进行过滤；</p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>jump_error_value作为一个很重要的值，没有进行有效利用。</p>
<p>上述两个问题会导致数据质量不高，干扰项太多，目标函数拟合速度太慢。</p>
<p>因此改进数据采集策略：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> jump_error_value &lt; <span class="number">5</span> <span class="keyword">and</span> last_piece_x &gt; <span class="number">0</span> <span class="keyword">and</span> last_press_time &gt; <span class="number">0</span> <span class="keyword">and</span> target_distance &gt; <span class="number">0</span> <span class="keyword">and</span> actual_distance &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	ai.add_data(round(actual_distance, <span class="number">2</span>), round(last_press_time))</span></pre></td></tr></table></figure>
<h2 id="改进1"><a href="#改进1" class="headerlink" title="改进1"></a>改进1</h2><p>要求target_distance与actual_distance必须要大于0才是有效值，剔除干扰项；</p>
<h2 id="改进2"><a href="#改进2" class="headerlink" title="改进2"></a>改进2</h2><p>jump_error_value合理利用，开始时将此参数放大到50左右，后续根据学习效果，逐步缩小jump_error_value的阈值，提高精确度，加速训练效果。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><h2 id="训练数据拟合函数"><a href="#训练数据拟合函数" class="headerlink" title="训练数据拟合函数"></a>训练数据拟合函数</h2><p>经过大概四五轮训练，采样到571条数据，拟合出线性回归函数如图<br><img src="/images/snipaste_20180107_143133.png" alt=""> </p>
<h2 id="debug误差效果"><a href="#debug误差效果" class="headerlink" title="debug误差效果"></a>debug误差效果</h2><ol>
<li><p>运行debug截图, 基本完美命中目标<br><img src="/images/snipaste_20180107_132535.png" alt=""> </p>
</li>
<li><p>运行debug日志，误差基本控制在40以内<br><img src="/images/snipaste_20180107_130834.png" alt=""> </p>
</li>
</ol>
<h2 id="自动运行视频"><a href="#自动运行视频" class="headerlink" title="自动运行视频"></a>自动运行视频</h2><video id="video" controls="controls" preload="auto">
  <source id="mp4" src="/images/wechat_ai.mp4" type="video/mp4" poster="/images/snipaste_20180107_163211.png">
</video >


<h2 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h2><p>因为MX3手机硬件有问题，电量低于75%就会出现屏幕抖动，所以目前成绩如此<br><img src="/images/wechat_ai_20180107141219.jpg" alt="AI成绩"> </p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>优化后的代码以及训练数据： <a href="https://github.com/toddlerya/WechatJumpAI" target="_blank" rel="noopener">https://github.com/toddlerya/WechatJumpAI</a></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>不得不承认，机器学习在合适的领域使用合适方式，达到的效果非常棒！只用了简单的线性回归算法，最经典最基本的机器学习算法，达到的效果已经秒杀人类上千倍。<br>为了不被这个时代淘汰，一定要跟上节奏，加油~</p>
<hr>
<p>2018年01月07日 于 南京<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/31/Golang%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/31/Golang%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/" class="post-title-link" itemprop="url">Golang学习（二）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-31 16:13:51" itemprop="dateCreated datePublished" datetime="2017-12-31T16:13:51+08:00">2017-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%80%A0%E8%BD%AE%E5%AD%90/" itemprop="url" rel="index">
                    <span itemprop="name">造轮子</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="闲扯"><a href="#闲扯" class="headerlink" title="闲扯"></a>闲扯</h1><p>2017年的最后一天啦！今天是最后一批90后（1999年12月31日出生）的18岁生日，祝他们生日快乐！明天就是2018年啦，意味着90后已经全部成年，逐步成为社会的中流砥柱啦！<br>顺便吐槽下，被朋友圈的18岁照片刷屏啦，岁月是把杀猪刀，18岁的少年们都去哪啦！小伙伴们不要只顾着工作，也注意下身体啊，要变强不要变秃啊！不要变成油腻的中年胖子啊！</p>
<p>祝自己在2018年能更加努力，锻炼好身体！还有很多很多事情等我去做！Fight！</p>
<p>言归正传，在<a href="!--￼4--">Golang学习（一）</a>那篇博客中我们写了一个小工具，当时还没学习到并发，正好元旦假期学习了下并发，来实践改进下我们的工具。</p>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="遗留Bug修复"><a href="#遗留Bug修复" class="headerlink" title="遗留Bug修复"></a>遗留Bug修复</h2><p>文件复制过程中异常报错，程序没有退出的问题已经修复，创建文件和打开文件时加入了panic</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">srcFile, err := os.Open(src)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">panic</span>(<span class="string">"打开文件错误!"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> srcFile.Close()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">desFile, err := os.Create(des)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    fmt.Println(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">panic</span>(<span class="string">"创建文件错误!"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> desFile.Close()</span></pre></td></tr></table></figure>

<h2 id="使用Golang的gorutine来并发，提高性能"><a href="#使用Golang的gorutine来并发，提高性能" class="headerlink" title="使用Golang的gorutine来并发，提高性能"></a>使用Golang的gorutine来并发，提高性能</h2><p>创建一个容量与期望生成文件个数大小相当的布尔型的<b>chan</b>，然后循环执行任务，每次向<b>chan</b>写入一个值，并通过读取<b>chan</b>来阻塞<b>main</b>函数的结束，伪代码如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, *generateFileNumber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; *generateFileNumber; count++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        dosomething(c)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &lt;-c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">(c)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    do</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    c &lt;- <span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * User: toddlerya</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Date: 2017/12/23</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * Update: 2017/12/31</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * ds接入模块加压工具</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"flag"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"fmt"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"io"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"math/rand"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"os"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"runtime"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"strconv"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"strings"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	<span class="string">"time"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">judgeExists</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> _, err := os.Stat(name); err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> os.IsNotExist(err) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">bool</span>, src, des <span class="keyword">string</span>)</span> <span class="params">(w <span class="keyword">int64</span>, err error)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	srcFile, err := os.Open(src)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">panic</span>(<span class="string">"打开文件错误!"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">defer</span> srcFile.Close()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">	desFile, err := os.Create(des)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(err)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">panic</span>(<span class="string">"创建文件错误!"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">defer</span> desFile.Close()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">	c &lt;- <span class="literal">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> io.Copy(desFile, srcFile)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateRandomNumber</span><span class="params">(start <span class="keyword">int</span>, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> end &lt; <span class="number">0</span> || start &lt; <span class="number">0</span> || (end-start) &lt;= <span class="number">0</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(<span class="string">"[-] 随机数起始值[start]必须大于等于0, 截至值[end]必须大于起始值!"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">		fmt.Printf(<span class="string">"[-] 请检查配置是否正确: start=%v, end=%v\n"</span>, start, end)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">panic</span>(<span class="string">"随机数参数错误"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">	rand.Seed(time.Now().UnixNano())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">	num := rand.Intn((end - start)) + start</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> num</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">	srcFilePath := flag.String(<span class="string">"s"</span>, <span class="string">"/home"</span>, <span class="string">"输入原始文件路径"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">	dstFilePath := flag.String(<span class="string">"d"</span>, <span class="string">"/tmp"</span>, <span class="string">"目标输出路径"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">	renameFormat := flag.String(<span class="string">"f"</span>, <span class="string">"abc-&#123;random1&#125;-456_780_&#123;random2&#125;.zip"</span>, <span class="string">"参数原始文件替换格式"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">	random1Start := flag.Int(<span class="string">"r1s"</span>, <span class="number">100</span>, <span class="string">"随机参数1的起始值"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">	random1End := flag.Int(<span class="string">"r1e"</span>, <span class="number">999</span>, <span class="string">"随机参数1的截止值"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">	random2Start := flag.Int(<span class="string">"r2s"</span>, <span class="number">100000</span>, <span class="string">"随机参数2的起始值"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">	random2End := flag.Int(<span class="string">"r2e"</span>, <span class="number">999999</span>, <span class="string">"随机参数2的截止值"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">	generateFileNumber := flag.Int(<span class="string">"g"</span>, <span class="number">10000</span>, <span class="string">"需要生成的文件个数"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">	flag.Parse()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[srcFilePath]          :%s\n"</span>, *srcFilePath)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[dstFilePath]          :%s\n"</span>, *dstFilePath)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[renameFormat]         :%s\n"</span>, *renameFormat)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[random1Start]         :%v\n"</span>, *random1Start)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[random1End]           :%v\n"</span>, *random1End)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[random2Start]         :%v\n"</span>, *random2Start)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[random2End]           :%v\n"</span>, *random2End)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">	fmt.Printf(<span class="string">"[generateFileNumber]   :%v\n"</span>, *generateFileNumber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"======================================="</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">	t1 := time.Now()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> judgeExists(*srcFilePath) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">		c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, *generateFileNumber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(<span class="string">"[+] 开始随机生成目标数据, 请注意"</span>, *dstFilePath, <span class="string">"目录是否有数据生成\t"</span>, <span class="string">"计划生成"</span>, *generateFileNumber, <span class="string">"个文件Orz"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> count := <span class="number">0</span>; count &lt; *generateFileNumber; count++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">			random1Val := generateRandomNumber(*random1Start, *random1End)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">			random2Val := generateRandomNumber(*random2Start, *random2End)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">			temp := strings.Replace(*renameFormat, <span class="string">"&#123;random1&#125;"</span>, strconv.Itoa(random1Val), <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">			newFileName := strings.Replace(temp, <span class="string">"&#123;random2&#125;"</span>, strconv.Itoa(random2Val), <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">			dstJoinList := []<span class="keyword">string</span>&#123;*dstFilePath, newFileName&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">			newDstFilePath := strings.Join(dstJoinList, <span class="string">"/"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">			<span class="comment">// fmt.Println("[*] 输出随机生成的文件: ", newDstFilePath)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">go</span> copyFile(c, *srcFilePath, newDstFilePath)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">		&lt;-c</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(<span class="string">"[+] 已经完成目标: 共计生成"</span>, *generateFileNumber, <span class="string">"个文件"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">		fmt.Println(<span class="string">"[-] 原始文件不存在, 请检查: "</span>, *srcFilePath)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">	elapsed := time.Since(t1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">	fmt.Println(<span class="string">"运行耗时: "</span>, elapsed)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="使用效果如下"><a href="#使用效果如下" class="headerlink" title="使用效果如下"></a>使用效果如下</h1><h2 id="没有使用gorutine之前"><a href="#没有使用gorutine之前" class="headerlink" title="没有使用gorutine之前"></a>没有使用gorutine之前</h2><p><img src="images/snipaste_20171231_163523.png" alt=""> </p>
<h2 id="使用gorutine后的并发效果"><a href="#使用gorutine后的并发效果" class="headerlink" title="使用gorutine后的并发效果"></a>使用gorutine后的并发效果</h2><p><img src="images/snipaste_20171231_163646.png" alt=""> </p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="images/snipaste_20171231_164046.png" alt=""> </p>
<p>第一次自己写的代码遇到这个文件打开数过多的问题，还有点小激动呢！查看下系统当前的<strong>ulimit open files</strong>配置值<br><img src="images/snipaste_20171231_164447.png" alt=""></p>
<p>果断手动改大些（个人笔记本，不会经常进新大量IO操作，就临时改下吧）<strong>ulimit -n 65535</strong><br><img src="images/snipaste_20171231_164748.png" alt=""> </p>
<p>修改后的使用效果就是上面的并发测试那个图啦！</p>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>其实还有一个使用了sync的版本，但是测试效果和没有使用并发的测试结果一样，甚至还要差一些，还是不懂的太多，留个坑，等搞明白了再来补充。<br><img src="images/snipaste_20171231_165138.png" alt=""> </p>
<p>相关伪代码逻辑如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    wg := sync.WaitGroup&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	wg.Add(*generateFileNumber)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> count := <span class="number">0</span>; count &lt; *generateFileNumber; count++ &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        dosomething(&amp;wg)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    wg.Wait()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dosomething</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    do</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    wg.Done()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#123;% endcodeblock %&#125;</span></pre></td></tr></table></figure>

<hr>
<p>2017年12月31日 于 南京<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/30/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E9%9B%86-%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="toddlerya">
      <meta itemprop="description" content="witness me.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不期速成日拱一卒">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/30/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E9%9B%86-%E5%A4%87%E5%BF%98%E6%B8%85%E5%8D%95/" class="post-title-link" itemprop="url">开源工具集--备忘清单</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-30 21:37:25" itemprop="dateCreated datePublished" datetime="2017-12-30T21:37:25+08:00">2017-12-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-09 23:35:36" itemprop="dateModified" datetime="2019-12-09T23:35:36+08:00">2019-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>经常看到一些有趣的开源工具，没机会去尝试，时间久了就忘记还有这些轮子啦，开个坑做个备忘录，记录下。</p>
<hr>
<h1 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h1><ul>
<li><a href="http://open-falcon.com/" target="_blank" rel="noopener">open-falcon</a></li>
<li><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a></li>
<li><a href="http://cockpit-project.org/guide/latest/" target="_blank" rel="noopener">Cockpit</a></li>
</ul>
<h1 id="数据分析-BI"><a href="#数据分析-BI" class="headerlink" title="数据分析/BI"></a>数据分析/BI</h1><ul>
<li><a href="https://www.metabase.com/" target="_blank" rel="noopener">Metabase</a></li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li>时间序列数据库<a href="https://portal.influxdata.com/downloads#influxdb" target="_blank" rel="noopener">influxdb</a></li>
</ul>
<hr>
<p>2017年10月22日 于 南京<br><a href="toddlerya@qq.com">Email</a><br><a href="https://github.com/toddlerya" target="_blank" rel="noopener">GitHub</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">toddlerya</p>
  <div class="site-description" itemprop="description">witness me.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/toddlerya" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;toddlerya" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:toddlerya@qq.com" title="E-Mail → mailto:toddlerya@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">toddlerya</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
