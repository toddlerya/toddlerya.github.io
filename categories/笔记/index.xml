<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记 on 不期速成日拱一卒</title>
    <link>https://toddlerya.github.io/categories/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记 on 不期速成日拱一卒</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 May 2019 09:37:20 +0800</lastBuildDate>
    
	<atom:link href="https://toddlerya.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LIMIT和IFNULL的使用：LeetCode No.176</title>
      <link>https://toddlerya.github.io/post/limit%E5%92%8Cifnull%E7%9A%84%E4%BD%BF%E7%94%A8leetcode-sqlno.176/</link>
      <pubDate>Sun, 12 May 2019 09:37:20 +0800</pubDate>
      
      <guid>https://toddlerya.github.io/post/limit%E5%92%8Cifnull%E7%9A%84%E4%BD%BF%E7%94%A8leetcode-sqlno.176/</guid>
      <description>​ 下班在家无聊打开力扣（LeetCode国内版）随便逛逛，突然发现还有SQL题目，随便点开一道简单的题目，平常一般也就用用普通的CURD、分组、排序，多表关联查询什么的，这道题我是没做出来！各位小伙伴看看这道题，大家会不会做～这道题是这样子的：
看起来普普通通哦，第一反应，排个序嘛～
SELECT DISTINCT(Salary) AS SecondHighestSalary FROM Employee ORDER BY Salary DESC;  再然后就发现卡壳了，触发了我的知识盲区！
 如何只取出第2行数据？ 如何判断是否有第二高的薪水（有可能所有人薪水都一样或空表的情况）？ 如何返回null？  开始补习功课！
各种数据库的SQL有一定差异，我们以使用较多的MySQL数据库的SQL语法为例。
一、回顾LIMIT子句知识细节 首先我们回顾下如何限制只返回查询结果的前两行？
SELECT some_col FROM some_table LIMIT 2;  上述代码使用SELECT语言检索单独的一列数据。LIMIT 2指示MySQL数据库返回不超过2行的数据，其实这就是我们平时最常用的LIMIT子句，但这不是完整的LIMIT子句。
知识点来了！
1. LIMIT子句的完整形态是这样子的： LIMIT return_rows_number OFFSET start_index  2. OFFSET默认值为0： 我们上面语句的LIMIT 2其实是LIMIT 2 OFFSET 0的默认简写形式，不显式声明OFFSET值，则OFFSET默认为0。
3. 简化版的LIMIT子句： LIMIT start_index, return_rows_number  接下来我们实战下看看效果，加深下理解：
对于这道题，我们要获取第二行数据，应该这样写
SELECT DISTINCT(Salary) FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1;  二、回顾IFNULL函数的细节 MySQL的IFNULL函数其实就是个if else语句，函数语法规则如下</description>
    </item>
    
    <item>
      <title>robotframework字符转译之坑</title>
      <link>https://toddlerya.github.io/post/robotframework%E5%AD%97%E7%AC%A6%E8%BD%AC%E8%AF%91%E4%B9%8B%E5%9D%91/</link>
      <pubDate>Mon, 08 Apr 2019 23:19:16 +0800</pubDate>
      
      <guid>https://toddlerya.github.io/post/robotframework%E5%AD%97%E7%AC%A6%E8%BD%AC%E8%AF%91%E4%B9%8B%E5%9D%91/</guid>
      <description>去年在公司推广了robotframework自动化框架，基于此框架我们设计开发了HTTPTestLibrary关键字库开展接口测试，效果挺好。我们部门测试开发的统一Python版本为python2.7，因为在我来公司前就在用这个版本，虽然2020年社区不再提供支持，但我们目前还没有迁移Python3的计划，这是前提。
有点别致的JSON 说到接口测试，必然要支持解析处理各种请求体，其中，我们的研发在某些项目的接口中使用了这样的请求体，我举个例子：
{&amp;quot;key1&amp;quot;: 123, &amp;quot;trouble&amp;quot;: &amp;quot;{\&amp;quot;inner\&amp;quot;: \&amp;quot;hehe\&amp;quot;}&amp;quot;}  JSON里嵌套一个JSON对象，还是个字符串型的，这是个标准的JSON类型嘛？？？google得知如下知识
我们用Python测试下：
In [8]: json_str = r&#39;&#39;&#39;{&amp;quot;key1&amp;quot;: 123, &amp;quot;trouble&amp;quot;: &amp;quot;{\&amp;quot;inner\&amp;quot;: \&amp;quot;hehe\&amp;quot;}&amp;quot;}&#39;&#39;&#39; In [9]: json_str Out[9]: &#39;{&amp;quot;key1&amp;quot;: 123, &amp;quot;trouble&amp;quot;: &amp;quot;{\\&amp;quot;inner\\&amp;quot;: \\&amp;quot;hehe\\&amp;quot;}&amp;quot;}&#39; In [10]: print(json_str) {&amp;quot;key1&amp;quot;: 123, &amp;quot;trouble&amp;quot;: &amp;quot;{\&amp;quot;inner\&amp;quot;: \&amp;quot;hehe\&amp;quot;}&amp;quot;} In [11]: import json In [12]: json.loads(json_str) Out[12]: {&#39;key1&#39;: 123, &#39;trouble&#39;: &#39;{&amp;quot;inner&amp;quot;: &amp;quot;hehe&amp;quot;}&#39;} In [13]: type(json.loads(json_str)) Out[13]: dict  研发定义的请求体没毛病，接下来看看我们的Python2的robotframework遇到什么问题了。
robotframework测试用例 我们的robotframework测试用例如下：
基于我们对robotframework的了解，robotframework会读取文本格式的robot测试用例，经过解析加载为内存对象，构建测试用例，我们先分别使用Python2和Python3读取测试用例，看看效果是什么样子：
可以看到，虽然python2和python3对字符串的类型处理方式不同，但是对于我们的测试用例文本，都只进行了转译加上了一个\。
为了方便定位问题，便于观察，我们统一修改了robotframework的源码，增加了文本用例解析的输出
Python2版本的robotframework同学登场 先看下robotframework的测试执行结果，看起来没毛病。
再看看测试用例的debug输出：
WTF！为神马变成了四个\???，这就是导致我们的请求体异常，接口响应错误的根本原因啊！
可是在上面的的Python2直接读取测试用例表现的不是这样啊！
稳住，我们不能冤枉Python2同学，我们看看Python3的表现。
Python3版本的robot framework同学低调入场  Python3版本我们使用pipenv创建了一个虚拟环境，同样也修改了robotframework的源码，输出repr</description>
    </item>
    
    <item>
      <title>当开发团队开始用Docker，测试团队应该做什么？</title>
      <link>https://toddlerya.github.io/post/%E5%BD%93%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%BC%80%E5%A7%8B%E7%94%A8docker%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88/</link>
      <pubDate>Fri, 01 Mar 2019 20:29:16 +0800</pubDate>
      
      <guid>https://toddlerya.github.io/post/%E5%BD%93%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E5%BC%80%E5%A7%8B%E7%94%A8docker%E6%B5%8B%E8%AF%95%E5%9B%A2%E9%98%9F%E5%BA%94%E8%AF%A5%E5%81%9A%E4%BB%80%E4%B9%88/</guid>
      <description>在之前的《Hello Docker》中，简单介绍过Docker，但仅限于在测试开发团队内部使用，或者说更多的是我个人在使用Orz，等了好久终于公司的研发团队开始正式使用Docker了。这次来西安分公司学习下公司基于Docker和K8S开发的容器云平台，深入了解了下Docker的底层原理，简单学习了下K8S的基本概念和操作，感觉对于研发团队来说，容器化的迁移还是有一定成本的。
Docker带来了什么？改变了什么？ 一、传统软件开发流程有几大痛点：  开发、测试、发布环境不统一
 配置测试环境过程冗长又复杂
 自动化测试环境不稳定，容易受到污染，隔离不足
 无法准确获得客户的软件环境
 开发团队无法复现测试团队报出的软件缺陷，导致两个团队出现相互推诿的现象
  二、当前测试技术面临的几大挑战：  配置一致的测试环境 快速部署软件 并行执行测试，在并行的同时还要保证测试任务各自的环境不被污染 成功的复现软件缺陷 创建干净的可信的测试环境 快速部署多个测试主机 快速导入测试数据 快速清理测试环境 快速保留、复制、恢复测试环境 正确配置测试工具。快速将测试环境在不同操作系统（类Unix）  三、Docker对测试技术的革命性影响 软件开发交付速度上不去，很大一个问题是软件运行环境这个环节存在瓶颈，Docker解决了这个瓶颈，促进了软件开发的DevOps模式推广，这对所有的软件行业从业者都是巨大利好。
软件测试的几个重要方面：测试策略、测试设计、测试方法、测试数据、测试环境，前三个是方法论思想层面的，后两个是需要技术突破的。测试数据因具体细分行业不同，各有各的痛点也各有各的解决方案，但是对于测试环境来说，Docker是个近乎接近“银弹”的技术解决方案。
通过Docker的软件环境快速部署能力，促进了测试时间的再分配 一个小小的Dockerfile明确声明了软件部署的所有细节和流程，从此忘记冗长的安装部署文档吧！无论是从研发自测、功能测试、集成测试等哪个环节来讲，测试环境的部署时间成倍缩短，能给工程师更多的时间做更多有意义的事情，开发工程师可以有更多时间完善优化设计，修复缺陷，测试工程师可以有跟多时间拓宽测试的广度和提高测试的深度，运维工程师有更多的时间专注于改进软件监控分析系统，这和有效的自动化测试的价值可以相提并论。
通过Docker的软件环境一致性能力，有效降低了偶然复杂度 Docker的镜像发布，容器编排运行等设计实现，保证了开发环境、测试环境、生产发布环境以及不同操作系统发行版的高度一致可信，几乎避免了测试团队发现的缺陷在开发环境无法复现、线上生产环境的缺陷在线下无法复现且不便线上调试等问题带来的一些列人力成本、时间成本、心智成本的无谓消耗。
通过Docker的环境隔离管理能力，提高了测试资源的自由度 以往虽然有各种虚拟化技术，可以一台服务器虚拟化为多台虚拟机，可以对虚拟机进行快照，随时恢复软件环境，但是终究太笨重，资源损耗太高，利用率太低，无法实现测试资源自由。现在有了Docker的资源隔离管理能力，我们可以按照测试需求，启动多个不同版本的服务，随时创建，随时销毁；我们甚至可以在一台服务器给每个测试人员启动一套独立的测试环境，大家并行测试，互不干扰，避免了互相踩踏。同时这种环境资源的自由度，对于自动化测试的执行过程是有很大帮助的，大大提高了自动化测试的成功率，进而提高自动化测试的ROI。
测试团队如何顺势而为？ 上一小节总结的三点革命性影响，对于整个开发流程来说，已经为CI/CD提供了道路基石，势必将进一步缩短迭代周期，提高交付速度（虽然还是有需求变更，开发延期等软件开发管理上不可避免的问题和人的不可靠性等因素等debuff）
效率提高了，交付速度提高了，迭代速度更快了，单纯的手工测试已经跟不上DevOps的软件开发模式了（其实在很多年前就跟不上现代软件开发节奏了），对测试的要求更高了，应当思考下省下来的时间如何更好的利用，如何跟上研发提测的速度。对于我现在所在的这种相对传统的行业软件服务企业来说，测试团队必须尽快适应这种DevOps开发模式了，不然就会被历史的车轮碾死在尘埃里。
测试团队的核心职责是质量保障，围绕质量保障，我们可以将测试能力向前向后输出，输出的最好形式就是自动化。
 自动化测试环境资源不再是自动化实施的绊脚石，接下来需要考验的是我们的自动化框架、自动化工具是否真的可靠、可用。 测试驱动开发的模式虽然很好，但是推广落地却不是那么容易的😊。测试团队还可以将测试用例封装为自动化测试服务，提供给研发自测，而不是等研发一次次快速提测再被打回，冲击消耗测试工程师的激情和精力。更近一步可以考虑通过感知镜像仓库中镜像的变化，动态触发自动化测试。当然长远看来还是要与开发团队共同实现CI/CD，需要各个研发部门通力合作。 软件运行环境的高度一致性，理论上线上发现的缺陷可以等价于测试团队漏测，这对测试团队的可信度和口碑是一个挑战，需要进一步提高测试质量和标准 上线后的软件运行状态检测，虽然按照传统分工应当是运维团队来做的，但是测试团队在这方面也有自己得天独厚的优势，对产品的深刻理解，测试角度，可以将内测测试用例调整转为适配线上数据环境的在线自动化测试用例，实现线上测试，在第一时间发现由于线上环境测试数据的多样性和量级带来的问题，及时收集触发线上自动化用例失败的测试数据来完善测试用例库，提高测试覆盖度。  总而言之，核心就是进一步提高自动化测试技术的深度和广度。
暂时想到这些，有新的想法再补充。
 Reference
https://www.infoq.cn/article/docker-lead-test-innovation
 2019年03月01日 于 西安
Email
GitHub</description>
    </item>
    
    <item>
      <title>Hello Docker</title>
      <link>https://toddlerya.github.io/post/hello-docker/</link>
      <pubDate>Sat, 05 Jan 2019 12:08:32 +0800</pubDate>
      
      <guid>https://toddlerya.github.io/post/hello-docker/</guid>
      <description>说起来Docker，大家都或多或少有耳闻，但是我的公司因为业务场景，长尾效应，至今为止Docker只在小部分项目轻度使用。但是这不妨碍我们主动学习，应用Docker，因此，从2018年开始，我就推动Docker在测试部应用。我们的测试平台，GitLab、JIRA、Confluence等都是通过Docker部署的。
团队内部做算法测试的同学搭建开发测试环境需要安装各种第三方库，因为工作环境是内网，无法连接互联网进行安装，痛苦不堪，使用Docker将相关环境在外网构建好传入内网使用是比较方便的方式；还有工具链建设、测试平台建设用到的各种基础设施MySQL、Nginx等快速部署，使用Docker都是最佳方案。为了方便团队同学了解Docker，团队老大让我来进行一次内部Docker入门分享。
没有Docker的从前 为了提高服务器利用效率，我们将一台高性能的服务器通过vSphere虚拟化，创建多台虚拟机，提供相对独立环境隔离的操作系统环境和计算资源，我们可以对每一台虚拟机灵活分配计算资源、存储资源等，还可以对每一台虚拟机创建多个快照，看起来很棒！是的，在传统的软件开发模式下，这种方式挺好，但是这并没有解决软件的部署效率低，交付困难，开发环境与测试环境不一致，测试环境与生产环境不一致等问题，这也是为什么我们有了持续集成，却没有做好持续交付的一大根本问题。
有了Docker的现在 各大互联网厂商都在使用Docker，通过Docker结合微服务等技术他们将DevOps这一理念落地了，真正做到了持续集成、持续部署、持续交付，快速迭代，可以实现一天多次版本上线发布！回头看有了Docker我们在日常工作中能做什么，举个最简单的例子：
以往我们想部署三套环境（一套Dev环境、一套Test环境、一套Release环境），需要三个MySQL数据库，需要怎么做呢？
 方案1：准备三台服务器，分别安装MySQL，干干净净，互不干扰，但是浪费资源啊； 方案2：一台服务器部署三个MySQL实例，分别配置不同的MySQL数据存储路径、配置文件路径、端口，操作复杂，维护困难，想想都头疼；  用Docker以后呢，我们可以这样做：
docker run --name release-mysql -p 3306:3306 -d mysql:5.7 docker run --name dev-mysql -p 3307:3306 -d mysql:5.7 docker run --name test-mysql -p 3308:3306 -d mysql:5.7  这样我们就有了三个独立的MySQL数据库服务！当然这是个示例，没有做数据卷映射等配置，但那些配置相比于传统方案来说，复杂度不值一提。
Docker到底是什么 Docker 是世界领先的软件容器平台。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。
什么是容器呢？  将软件打包成标准化单元，以用于开发、交付和部署  容器镜像是轻量的、可执行的独立软件包，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。
容器的优势特点 轻量 在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。
标准 Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</description>
    </item>
    
  </channel>
</rss>